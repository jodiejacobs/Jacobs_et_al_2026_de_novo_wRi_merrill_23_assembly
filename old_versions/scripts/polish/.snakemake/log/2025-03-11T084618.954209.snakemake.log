host: emerald.prism
Building DAG of jobs...
SLURM run ID: 4ae087df-78e5-45da-8522-424318e8c4ba
Using shell: /usr/bin/bash
Provided remote nodes: 10
Conda environments: ignored
Job stats:
job                          count
-------------------------  -------
all                              1
circularize_merged               1
merge_assemblies                 1
polish_merged_short_reads        1
total                            4

Select jobs to execute...
Execute 1 jobs...

[Tue Mar 11 08:46:19 2025]
rule merge_assemblies:
    input: /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_AN/wRi/polished.fasta, /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_JJ/wRi/polished.fasta, /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/longest_contigs_bridge/wRi/polished.fasta, /private/groups/russelllab/jodie/merrill_23_wRi_genome/nanopore_data/basecalled/merrill_23_all_basecalled.wRi.fastq.gz
    output: /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/wRi/merged.fasta
    jobid: 6
    reason: Missing output files: /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/wRi/merged.fasta
    threads: 32
    resources: mem_mb=100000, mem_mib=95368, disk_mb=1000, disk_mib=954, tmpdir=<TBD>, slurm_partition=medium, runtime=480

No SLURM account given, trying to guess.
Unable to guess SLURM account. Trying to proceed without.
Job 6 has been submitted with SLURM jobid 6869464 (log: /private/groups/russelllab/jodie/merrill_23_wRi_genome/de_novo_wRi_merrill_23_assembly/scripts/polish/.snakemake/slurm_logs/rule_merge_assemblies/6869464.log).
[Tue Mar 11 08:47:00 2025]
Error in rule merge_assemblies:
    message: SLURM-job '6869464' failed, SLURM status is: 'FAILED'. For further error details see the cluster/cloud log and the log files of the involved rule(s).
    jobid: 6
    input: /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_AN/wRi/polished.fasta, /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_JJ/wRi/polished.fasta, /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/longest_contigs_bridge/wRi/polished.fasta, /private/groups/russelllab/jodie/merrill_23_wRi_genome/nanopore_data/basecalled/merrill_23_all_basecalled.wRi.fastq.gz
    output: /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/wRi/merged.fasta
    log: /private/groups/russelllab/jodie/merrill_23_wRi_genome/de_novo_wRi_merrill_23_assembly/scripts/polish/.snakemake/slurm_logs/rule_merge_assemblies/6869464.log (check log file(s) for error details)
    shell:
        
        # Create output directories
        mkdir -p /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/wRi/
        mkdir -p /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp/
        
        # 1. Identify the best assembly based on BUSCO completeness
        # Create a list of all polished assemblies
        ls -1 /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_AN/wRi/polished.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_JJ/wRi/polished.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/longest_contigs_bridge/wRi/polished.fasta > /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//assembly_list.txt
        
        # First, select the most complete assembly as a base
        # For simplicity, we'll choose the assembly with the most contigs over 10kb
        BEST_ASSEMBLY=""
        MAX_CONTIGS=0
        
        for ASSEMBLY in /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_AN/wRi/polished.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_JJ/wRi/polished.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/longest_contigs_bridge/wRi/polished.fasta; do
            ASSEMBLY_NAME=$(basename $(dirname $(dirname $ASSEMBLY)))
            
            # Count contigs over 10kb
            LARGE_CONTIGS=$(awk '/^>/{if(len>10000) count++; len=0; next} {len+=length($0)} END{if(len>10000) count++; print count}' $ASSEMBLY)
            
            echo "Assembly $ASSEMBLY_NAME has $LARGE_CONTIGS large contigs" > /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//$ASSEMBLY_NAME.stats
            
            if [ "$LARGE_CONTIGS" -gt "$MAX_CONTIGS" ]; then
                MAX_CONTIGS=$LARGE_CONTIGS
                BEST_ASSEMBLY=$ASSEMBLY
            fi
        done
        
        echo "Selected $BEST_ASSEMBLY as base assembly with $MAX_CONTIGS large contigs" > /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//selected_assembly.txt
        
        # 2. Use Quickmerge to merge all assemblies
        # First copy the best assembly as the initial merged assembly
        cp $BEST_ASSEMBLY /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_initial.fasta
        
        # Then iteratively merge other assemblies
        for ASSEMBLY in /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_AN/wRi/polished.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_JJ/wRi/polished.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/longest_contigs_bridge/wRi/polished.fasta; do
            if [ "$ASSEMBLY" != "$BEST_ASSEMBLY" ]; then
                ASSEMBLY_NAME=$(basename $(dirname $(dirname $ASSEMBLY)))
                echo "Merging $ASSEMBLY_NAME..."
                
                # Use Quickmerge to combine assemblies
                # Generate nucmer alignment
                nucmer --maxmatch -l 100 -c 500 -p /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//nucmer_out /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_initial.fasta $ASSEMBLY
                
                # Run quickmerge
                quickmerge -d /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//nucmer_out.delta -q /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_initial.fasta -r $ASSEMBLY -hco 5.0 -c 1.5 -l 10000 -ml 10000 -o /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_step.fasta
                
                # Update the merged assembly for the next iteration
                if [ -s /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_step.fasta ]; then
                    mv /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_step.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_initial.fasta
                fi
            fi
        done
        
        # 3. Use long reads to try to resolve any remaining gaps with TGS-GapCloser
        # Map nanopore reads to the merged assembly
        minimap2 -ax map-ont -t 32 /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_initial.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/nanopore_data/basecalled/merrill_23_all_basecalled.wRi.fastq.gz > /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_mapped.sam
        
        # Convert to BAM and sort
        samtools view -bS /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_mapped.sam | samtools sort -o /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_mapped.bam -
        
        # Index the BAM file
        samtools index /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_mapped.bam
        
        # Use TGS-GapCloser if available, otherwise just use the merged assembly
        if command -v TGS-GapCloser &> /dev/null; then
            # Extract reads
            samtools fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_mapped.bam > /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//mapped_reads.fasta
            
            # Run TGS-GapCloser
            tgsgapcloser                 --input_scaff /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_initial.fasta                 --reads /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//mapped_reads.fasta                 --output /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/wRi//gap_closed                 --min_match 300                 --min_coverage 3                 --threads 32
                
            # Check if gap closing was successful
            if [ -s /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/wRi//gap_closed.scaff_seqs ]; then
                mv /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/wRi//gap_closed.scaff_seqs /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/wRi/merged.fasta
            else
                # If gap closing failed, use the merged assembly
                cp /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_initial.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/wRi/merged.fasta
            fi
        else
            # If TGS-GapCloser is not available, use the merged assembly
            cp /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_initial.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/wRi/merged.fasta
        fi
        
        # Clean up temporary files
        # rm -rf /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp/
        
        (one of the commands exited with non-zero exit code; note that snakemake uses bash strict mode!)
    external_jobid: 6869464

Shutting down, this might take some time.
Exiting because a job execution failed. Look above for error message
Complete log: .snakemake/log/2025-03-11T084618.954209.snakemake.log
WorkflowError:
At least one job did not complete successfully.
