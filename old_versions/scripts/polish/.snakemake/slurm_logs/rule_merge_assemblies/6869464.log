host: phoenix-06.prism
Building DAG of jobs...
Using shell: /usr/bin/bash
Provided remote nodes: 1
Provided resources: mem_mb=100000, mem_mib=95368, disk_mb=1000, disk_mib=954
Conda environments: ignored
Select jobs to execute...
Execute 1 jobs...

[Tue Mar 11 08:46:46 2025]
rule merge_assemblies:
    input: /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_AN/wRi/polished.fasta, /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_JJ/wRi/polished.fasta, /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/longest_contigs_bridge/wRi/polished.fasta, /private/groups/russelllab/jodie/merrill_23_wRi_genome/nanopore_data/basecalled/merrill_23_all_basecalled.wRi.fastq.gz
    output: /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/wRi/merged.fasta
    jobid: 0
    reason: Forced execution
    threads: 32
    resources: mem_mb=100000, mem_mib=95368, disk_mb=1000, disk_mib=954, tmpdir=<TBD>, slurm_partition=medium, runtime=480

host: phoenix-06.prism
Building DAG of jobs...
Using shell: /usr/bin/bash
Provided cores: 32
Rules claiming more threads will be scaled down.
Provided resources: mem_mb=100000, mem_mib=95368, disk_mb=1000, disk_mib=954
Conda environments: ignored
Select jobs to execute...
Execute 1 jobs...

[Tue Mar 11 08:46:47 2025]
localrule merge_assemblies:
    input: /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_AN/wRi/polished.fasta, /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_JJ/wRi/polished.fasta, /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/longest_contigs_bridge/wRi/polished.fasta, /private/groups/russelllab/jodie/merrill_23_wRi_genome/nanopore_data/basecalled/merrill_23_all_basecalled.wRi.fastq.gz
    output: /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/wRi/merged.fasta
    jobid: 0
    reason: Forced execution
    threads: 32
    resources: mem_mb=100000, mem_mib=95368, disk_mb=1000, disk_mib=954, tmpdir=/data/tmp, slurm_partition=medium, runtime=480

Merging assembly_AN...
1: PREPARING DATA
2,3: RUNNING mummer AND CREATING CLUSTERS
# reading input file "/private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//nucmer_out.ntref" of length 1423300
# construct suffix tree for sequence of length 1423300
# (maximum reference length is 2305843009213693948)
# (maximum query length is 18446744073709551615)
# process 14233 characters per dot
#...................................................................................................
# CONSTRUCTIONTIME /private/home/jomojaco/mambaforge/envs/snakemake_v8/opt/mummer-3.23/mummer /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//nucmer_out.ntref 0.33
# reading input file "/private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_AN/wRi/polished.fasta" of length 1483647
# matching query-file "/private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_AN/wRi/polished.fasta"
# against subject-file "/private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//nucmer_out.ntref"
# COMPLETETIME /private/home/jomojaco/mambaforge/envs/snakemake_v8/opt/mummer-3.23/mummer /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//nucmer_out.ntref 1.27
# SPACE /private/home/jomojaco/mambaforge/envs/snakemake_v8/opt/mummer-3.23/mummer /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//nucmer_out.ntref 2.80
4: FINISHING DATA
/usr/bin/bash: line 46: quickmerge: command not found
[Tue Mar 11 08:46:52 2025]
Error in rule merge_assemblies:
    jobid: 0
    input: /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_AN/wRi/polished.fasta, /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_JJ/wRi/polished.fasta, /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/longest_contigs_bridge/wRi/polished.fasta, /private/groups/russelllab/jodie/merrill_23_wRi_genome/nanopore_data/basecalled/merrill_23_all_basecalled.wRi.fastq.gz
    output: /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/wRi/merged.fasta
    shell:
        
        # Create output directories
        mkdir -p /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/wRi/
        mkdir -p /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp/
        
        # 1. Identify the best assembly based on BUSCO completeness
        # Create a list of all polished assemblies
        ls -1 /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_AN/wRi/polished.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_JJ/wRi/polished.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/longest_contigs_bridge/wRi/polished.fasta > /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//assembly_list.txt
        
        # First, select the most complete assembly as a base
        # For simplicity, we'll choose the assembly with the most contigs over 10kb
        BEST_ASSEMBLY=""
        MAX_CONTIGS=0
        
        for ASSEMBLY in /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_AN/wRi/polished.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_JJ/wRi/polished.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/longest_contigs_bridge/wRi/polished.fasta; do
            ASSEMBLY_NAME=$(basename $(dirname $(dirname $ASSEMBLY)))
            
            # Count contigs over 10kb
            LARGE_CONTIGS=$(awk '/^>/{if(len>10000) count++; len=0; next} {len+=length($0)} END{if(len>10000) count++; print count}' $ASSEMBLY)
            
            echo "Assembly $ASSEMBLY_NAME has $LARGE_CONTIGS large contigs" > /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//$ASSEMBLY_NAME.stats
            
            if [ "$LARGE_CONTIGS" -gt "$MAX_CONTIGS" ]; then
                MAX_CONTIGS=$LARGE_CONTIGS
                BEST_ASSEMBLY=$ASSEMBLY
            fi
        done
        
        echo "Selected $BEST_ASSEMBLY as base assembly with $MAX_CONTIGS large contigs" > /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//selected_assembly.txt
        
        # 2. Use Quickmerge to merge all assemblies
        # First copy the best assembly as the initial merged assembly
        cp $BEST_ASSEMBLY /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_initial.fasta
        
        # Then iteratively merge other assemblies
        for ASSEMBLY in /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_AN/wRi/polished.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_JJ/wRi/polished.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/longest_contigs_bridge/wRi/polished.fasta; do
            if [ "$ASSEMBLY" != "$BEST_ASSEMBLY" ]; then
                ASSEMBLY_NAME=$(basename $(dirname $(dirname $ASSEMBLY)))
                echo "Merging $ASSEMBLY_NAME..."
                
                # Use Quickmerge to combine assemblies
                # Generate nucmer alignment
                nucmer --maxmatch -l 100 -c 500 -p /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//nucmer_out /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_initial.fasta $ASSEMBLY
                
                # Run quickmerge
                quickmerge -d /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//nucmer_out.delta -q /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_initial.fasta -r $ASSEMBLY -hco 5.0 -c 1.5 -l 10000 -ml 10000 -o /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_step.fasta
                
                # Update the merged assembly for the next iteration
                if [ -s /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_step.fasta ]; then
                    mv /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_step.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_initial.fasta
                fi
            fi
        done
        
        # 3. Use long reads to try to resolve any remaining gaps with TGS-GapCloser
        # Map nanopore reads to the merged assembly
        minimap2 -ax map-ont -t 32 /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_initial.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/nanopore_data/basecalled/merrill_23_all_basecalled.wRi.fastq.gz > /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_mapped.sam
        
        # Convert to BAM and sort
        samtools view -bS /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_mapped.sam | samtools sort -o /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_mapped.bam -
        
        # Index the BAM file
        samtools index /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_mapped.bam
        
        # Use TGS-GapCloser if available, otherwise just use the merged assembly
        if command -v TGS-GapCloser &> /dev/null; then
            # Extract reads
            samtools fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_mapped.bam > /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//mapped_reads.fasta
            
            # Run TGS-GapCloser
            TGS-GapCloser                 --input_scaff /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_initial.fasta                 --reads /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//mapped_reads.fasta                 --output /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/wRi//gap_closed                 --min_match 300                 --min_coverage 3                 --threads 32
                
            # Check if gap closing was successful
            if [ -s /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/wRi//gap_closed.scaff_seqs ]; then
                mv /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/wRi//gap_closed.scaff_seqs /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/wRi/merged.fasta
            else
                # If gap closing failed, use the merged assembly
                cp /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_initial.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/wRi/merged.fasta
            fi
        else
            # If TGS-GapCloser is not available, use the merged assembly
            cp /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_initial.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/wRi/merged.fasta
        fi
        
        # Clean up temporary files
        # rm -rf /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp/
        
        (one of the commands exited with non-zero exit code; note that snakemake uses bash strict mode!)

Shutting down, this might take some time.
Exiting because a job execution failed. Look above for error message
Storing output in storage.
WorkflowError:
At least one job did not complete successfully.
srun: error: phoenix-06: task 0: Exited with exit code 1
[Tue Mar 11 08:46:52 2025]
Error in rule merge_assemblies:
    jobid: 0
    input: /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_AN/wRi/polished.fasta, /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_JJ/wRi/polished.fasta, /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/longest_contigs_bridge/wRi/polished.fasta, /private/groups/russelllab/jodie/merrill_23_wRi_genome/nanopore_data/basecalled/merrill_23_all_basecalled.wRi.fastq.gz
    output: /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/wRi/merged.fasta
    shell:
        
        # Create output directories
        mkdir -p /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/wRi/
        mkdir -p /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp/
        
        # 1. Identify the best assembly based on BUSCO completeness
        # Create a list of all polished assemblies
        ls -1 /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_AN/wRi/polished.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_JJ/wRi/polished.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/longest_contigs_bridge/wRi/polished.fasta > /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//assembly_list.txt
        
        # First, select the most complete assembly as a base
        # For simplicity, we'll choose the assembly with the most contigs over 10kb
        BEST_ASSEMBLY=""
        MAX_CONTIGS=0
        
        for ASSEMBLY in /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_AN/wRi/polished.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_JJ/wRi/polished.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/longest_contigs_bridge/wRi/polished.fasta; do
            ASSEMBLY_NAME=$(basename $(dirname $(dirname $ASSEMBLY)))
            
            # Count contigs over 10kb
            LARGE_CONTIGS=$(awk '/^>/{if(len>10000) count++; len=0; next} {len+=length($0)} END{if(len>10000) count++; print count}' $ASSEMBLY)
            
            echo "Assembly $ASSEMBLY_NAME has $LARGE_CONTIGS large contigs" > /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//$ASSEMBLY_NAME.stats
            
            if [ "$LARGE_CONTIGS" -gt "$MAX_CONTIGS" ]; then
                MAX_CONTIGS=$LARGE_CONTIGS
                BEST_ASSEMBLY=$ASSEMBLY
            fi
        done
        
        echo "Selected $BEST_ASSEMBLY as base assembly with $MAX_CONTIGS large contigs" > /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//selected_assembly.txt
        
        # 2. Use Quickmerge to merge all assemblies
        # First copy the best assembly as the initial merged assembly
        cp $BEST_ASSEMBLY /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_initial.fasta
        
        # Then iteratively merge other assemblies
        for ASSEMBLY in /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_AN/wRi/polished.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/assembly_JJ/wRi/polished.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/polished/longest_contigs_bridge/wRi/polished.fasta; do
            if [ "$ASSEMBLY" != "$BEST_ASSEMBLY" ]; then
                ASSEMBLY_NAME=$(basename $(dirname $(dirname $ASSEMBLY)))
                echo "Merging $ASSEMBLY_NAME..."
                
                # Use Quickmerge to combine assemblies
                # Generate nucmer alignment
                nucmer --maxmatch -l 100 -c 500 -p /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//nucmer_out /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_initial.fasta $ASSEMBLY
                
                # Run quickmerge
                quickmerge -d /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//nucmer_out.delta -q /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_initial.fasta -r $ASSEMBLY -hco 5.0 -c 1.5 -l 10000 -ml 10000 -o /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_step.fasta
                
                # Update the merged assembly for the next iteration
                if [ -s /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_step.fasta ]; then
                    mv /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_step.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_initial.fasta
                fi
            fi
        done
        
        # 3. Use long reads to try to resolve any remaining gaps with TGS-GapCloser
        # Map nanopore reads to the merged assembly
        minimap2 -ax map-ont -t 32 /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_initial.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/nanopore_data/basecalled/merrill_23_all_basecalled.wRi.fastq.gz > /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_mapped.sam
        
        # Convert to BAM and sort
        samtools view -bS /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_mapped.sam | samtools sort -o /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_mapped.bam -
        
        # Index the BAM file
        samtools index /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_mapped.bam
        
        # Use TGS-GapCloser if available, otherwise just use the merged assembly
        if command -v TGS-GapCloser &> /dev/null; then
            # Extract reads
            samtools fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_mapped.bam > /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//mapped_reads.fasta
            
            # Run TGS-GapCloser
            TGS-GapCloser                 --input_scaff /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_initial.fasta                 --reads /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//mapped_reads.fasta                 --output /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/wRi//gap_closed                 --min_match 300                 --min_coverage 3                 --threads 32
                
            # Check if gap closing was successful
            if [ -s /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/wRi//gap_closed.scaff_seqs ]; then
                mv /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/wRi//gap_closed.scaff_seqs /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/wRi/merged.fasta
            else
                # If gap closing failed, use the merged assembly
                cp /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_initial.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/wRi/merged.fasta
            fi
        else
            # If TGS-GapCloser is not available, use the merged assembly
            cp /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp//merged_initial.fasta /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/wRi/merged.fasta
        fi
        
        # Clean up temporary files
        # rm -rf /private/groups/russelllab/jodie/merrill_23_wRi_genome/merged_assembly/tmp/
        
        (one of the commands exited with non-zero exit code; note that snakemake uses bash strict mode!)

Shutting down, this might take some time.
Exiting because a job execution failed. Look above for error message
Storing output in storage.
WorkflowError:
At least one job did not complete successfully.
